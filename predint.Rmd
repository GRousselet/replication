---
title: "Prediction intervals"
author: "Guillaume A. Rousselet"
date: "`r Sys.Date()`"
output:
  pdf_document:
    fig_caption: no
    number_sections: no
    toc: yes
    toc_depth: 2
    # github_document:
    # html_preview: yes
    # toc: yes
    # toc_depth: 2
---

# Dependencies

```{r}
library(tibble)
library(ggplot2)
library(latex2exp)
library(beepr)
source("./code/functions.R")
source("./code/theme_gar.txt")
```

# Prediction intervals

## Example from Spence & Stanley (2024)

https://journals.sagepub.com/doi/10.1177/25152459231217932

```{r}
n1 <- 50
n2 <- 70
m1 <- 7.21
sd1 <- 2.20
ci <- predint(n1, n2, m1, sd1)
ci
```

# Simulation: normal distribution

In each simulation, perform 2 experiments. First experiment has $n1=30$, second has $n2=30$. Consider one-sample case.

Consider these rules to indicate support for a replication:  

- mean in sample 2, $m_2$, is contained in prediction interval from experiment 1;  
- $m_2$ is contained in the confidence interval from experiment 1.  

Consider PI for means and 20% trimmed means. 

```{r, eval=FALSE}
set.seed(44)
nsim <- 50000
simres <- matrix(NA, nrow = nsim, 2)
simres.tm <- matrix(NA, nrow = nsim, 2)
n1 <- 30
n2 <- 30
tp <- 0.2 # trimming percentage
aat <- .05 # arbitrary alpha threshold 

for(S in 1:nsim){
  samp1 <- rnorm(n1)
  ci1 <- t.test(samp1)$conf.int
  m1 <- mean(samp1)
  sd1 <- sd(samp1)
  pi <- predint(n1, n2, m1, sd1)
  samp2 <- rnorm(n2)
  # ci2 <- t.test(samp2)$conf.int
  m2 <- mean(samp2)
  # rule 1: m2 contained in prediction interval
  simres[S,1] <- m2 >= pi[1] && m2 <= pi[2]
  pi <- predint.tm(M = mean(samp1, trim=tp), 
                   sd = winsd(samp1, tr = tp),
                   orig.n = n1, 
                   new.n = n2, 
                   tr = tp, 
                   alpha = aat)
  tm2 <- mean(samp2, trim = tp) # 20% trimmed mean in 20% PI?
  simres.tm[S] <- tm2 >= pi[1] && tm2 <= pi[2]
  # rule 2: m2 contained in confidence interval
  simres[S,2] <- m2 >= ci1[1] && m2 <= ci1[2]
  ci1 <- trimci(samp1, tr = tp, alpha = aat)$ci
  simres.tm[S,2] <- tm2 >= ci1[1] && tm2 <= ci1[2]
}
save(file = "./data/predint_norm.RData",
     simres, simres.tm)
```

## Results
```{r}
load(file = "./data/predint_norm.RData")

# coverage
print("---Normal population---")
print("inference on means:")
print("PI  /  CI")
round(apply(simres, 2, mean), digits = 3)
print("inference on 20% trimmed means:")
round(apply(simres.tm, 2, mean), digits = 3)
```

Prediction interval works as intended, will nominal capture rate.  
Coverage using CI rule is too conservative, way below the 95% that could (wrongly) be expected.   
Coverage of PI for 20% trimmed means is a bit liberal.   

# Simulation: lognormal distribution

```{r, eval=FALSE}
set.seed(44)
nsim <- 50000
simres <- matrix(NA, nrow = nsim, 2)
simres.tm <- matrix(NA, nrow = nsim, 2)
n1 <- 30
n2 <- 30
tp <- 0.2 # trimming percentage
aat <- .05 # arbitrary alpha threshold 

for(S in 1:nsim){
  samp1 <- rlnorm(n1)
  ci1 <- t.test(samp1)$conf.int
  m1 <- mean(samp1)
  sd1 <- sd(samp1)
  pi <- predint(n1, n2, m1, sd1)
  samp2 <- rlnorm(n2)
  # ci2 <- t.test(samp2)$conf.int
  m2 <- mean(samp2)
  # rule 1: m2 contained in prediction interval
  simres[S,1] <- m2 >= pi[1] && m2 <= pi[2]
  pi <- predint.tm(M = mean(samp1, trim=tp), 
                   sd = winsd(samp1, tr = tp),
                   orig.n = n1, 
                   new.n = n2, 
                   tr = tp, 
                   alpha = aat)
  tm2 <- mean(samp2, trim = tp) # 20% trimmed mean in 20% PI?
  simres.tm[S] <- tm2 >= pi[1] && tm2 <= pi[2]
  # rule 2: m2 contained in confidence interval
  simres[S,2] <- m2 >= ci1[1] && m2 <= ci1[2]
  ci1 <- trimci(samp1, tr = tp, alpha = aat)$ci
  simres.tm[S,2] <- tm2 >= ci1[1] && tm2 <= ci1[2]
}
save(file = "./data/predint_lnorm.RData",
     simres, simres.tm)
```

## Results
```{r}
load(file = "./data/predint_lnorm.RData")

# coverage
print("---Lognormal population---")
print("inference on means:")
print("PI  /  CI")
round(apply(simres, 2, mean), digits = 3)
print("inference on 20% trimmed means:")
round(apply(simres.tm, 2, mean), digits = 3)
```

Coverage is lower under strong asymmetry for PI and CI methods on means. CI overlap remains high. Coverage using 20% trimmed means is at the nominal level.    

# Simulation: contaminated normal distribution

See Wilcox & Rousselet (2023) for details. 

```{r, eval=FALSE}
set.seed(44)
nsim <- 50000
simres <- matrix(NA, nrow = nsim, 2)
simres.tm <- matrix(NA, nrow = nsim, 2)
n1 <- 30
n2 <- 30
tp <- 0.2 # trimming percentage
aat <- .05 # arbitrary alpha threshold 

for(S in 1:nsim){
  samp1 <- cnorm(n1)
  ci1 <- t.test(samp1)$conf.int
  m1 <- mean(samp1)
  sd1 <- sd(samp1)
  pi <- predint(n1, n2, m1, sd1)
  samp2 <- cnorm(n2)
  # ci2 <- t.test(samp2)$conf.int
  m2 <- mean(samp2)
  # rule 1: m2 contained in prediction interval
  simres[S,1] <- m2 >= pi[1] && m2 <= pi[2]
  pi <- predint.tm(M = mean(samp1, trim=tp), 
                   sd = winsd(samp1, tr = tp),
                   orig.n = n1, 
                   new.n = n2, 
                   tr = tp, 
                   alpha = aat)
  tm2 <- mean(samp2, trim = tp) # 20% trimmed mean in 20% PI?
  simres.tm[S] <- tm2 >= pi[1] && tm2 <= pi[2]
  # rule 2: m2 contained in confidence interval
  simres[S,2] <- m2 >= ci1[1] && m2 <= ci1[2]
  ci1 <- trimci(samp1, tr = tp, alpha = aat)$ci
  simres.tm[S,2] <- tm2 >= ci1[1] && tm2 <= ci1[2]
}
save(file = "./data/predint_cnorm.RData",
     simres, simres.tm)
```

## Results
```{r}
load(file = "./data/predint_cnorm.RData")

# coverage
print("---Contaminated normal population---")
print("inference on means:")
print("PI  /  CI")
round(apply(simres, 2, mean), digits = 3)
print("inference on 20% trimmed means:")
round(apply(simres.tm, 2, mean), digits = 3)
```

Similar conclusion when outliers are common, though coverage is a bit too high when using 20% trimmed means. 

# Simulation: vary n

Inferences on means and 20% trimmed means.  
Sampling from normal, lognormal and contaminated normal populations.  
Two rules: CI and PI.  

```{r, eval=FALSE}
set.seed(44)
nsim <- 50000
nseq <- seq(10, 100, 10)
nn <- length(nseq)
simres.ci <- array(NA, dim = c(nsim, nn, 2, 3)) #nseq, m/tm, 3 pops
simres.pi <- array(NA, dim = c(nsim, nn, 2, 3))
tp <- 0.2 # trimming percentage
aat <- .05 # arbitrary alpha threshold 

for(S in 1:nsim){
  
  for(N in 1:nn){
    
    n <- nseq[N]
    
    # Normal population
    samp1 <- rnorm(n)
    ci1 <- t.test(samp1)$conf.int
    m1 <- mean(samp1)
    sd1 <- sd(samp1)
    pi <- predint(n, n, m1, sd1)
    samp2 <- rnorm(n)
    m2 <- mean(samp2)
    # rule 1: m2 contained in prediction interval
    simres.pi[S,N,1,1] <- m2 >= pi[1] && m2 <= pi[2]
    pi <- predint.tm(M = mean(samp1, trim=tp), 
                     sd = winsd(samp1, tr = tp),
                     orig.n = n, 
                     new.n = n, 
                     tr = tp, 
                     alpha = aat)
    tm2 <- mean(samp2, trim = tp) # 20% trimmed mean in 20% PI?
    simres.pi[S,N,2,1] <- tm2 >= pi[1] && tm2 <= pi[2]
    # rule 2: m2 contained in confidence interval
    simres.ci[S,N,1,1] <- m2 >= ci1[1] && m2 <= ci1[2]
    ci1 <- trimci(samp1, tr = tp, alpha = aat)$ci
    simres.ci[S,N,2,1] <- tm2 >= ci1[1] && tm2 <= ci1[2]
    
    # Lognormal population
    samp1 <- rlnorm(n)
    ci1 <- t.test(samp1)$conf.int
    m1 <- mean(samp1)
    sd1 <- sd(samp1)
    pi <- predint(n, n, m1, sd1)
    samp2 <- rlnorm(n)
    m2 <- mean(samp2)
    # rule 1: m2 contained in prediction interval
    simres.pi[S,N,1,2] <- m2 >= pi[1] && m2 <= pi[2]
    pi <- predint.tm(M = mean(samp1, trim=tp), 
                     sd = winsd(samp1, tr = tp),
                     orig.n = n, 
                     new.n = n, 
                     tr = tp, 
                     alpha = aat)
    tm2 <- mean(samp2, trim = tp) # 20% trimmed mean in 20% PI?
    simres.pi[S,N,2,2] <- tm2 >= pi[1] && tm2 <= pi[2]
    # rule 2: m2 contained in confidence interval
    simres.ci[S,N,1,2] <- m2 >= ci1[1] && m2 <= ci1[2]
    ci1 <- trimci(samp1, tr = tp, alpha = aat)$ci
    simres.ci[S,N,2,2] <- tm2 >= ci1[1] && tm2 <= ci1[2]
    
    # Contaminated normal population
    samp1 <- cnorm(n)
    ci1 <- t.test(samp1)$conf.int
    m1 <- mean(samp1)
    sd1 <- sd(samp1)
    pi <- predint(n, n, m1, sd1)
    samp2 <- cnorm(n)
    m2 <- mean(samp2)
    # rule 1: m2 contained in prediction interval
    simres.pi[S,N,1,3] <- m2 >= pi[1] && m2 <= pi[2]
    pi <- predint.tm(M = mean(samp1, trim=tp), 
                     sd = winsd(samp1, tr = tp),
                     orig.n = n, 
                     new.n = n, 
                     tr = tp, 
                     alpha = aat)
    tm2 <- mean(samp2, trim = tp) # 20% trimmed mean in 20% PI?
    simres.pi[S,N,2,3] <- tm2 >= pi[1] && tm2 <= pi[2]
    # rule 2: m2 contained in confidence interval
    simres.ci[S,N,1,3] <- m2 >= ci1[1] && m2 <= ci1[2]
    ci1 <- trimci(samp1, tr = tp, alpha = aat)$ci
    simres.ci[S,N,2,3] <- tm2 >= ci1[1] && tm2 <= ci1[2]
  }
}
save(file = "./data/predint_sim.RData",
     simres.ci, simres.pi, nseq, nn, nsim, aat, tp)
```

## Plot results: prediction interval rule

```{r}
load(file = "./data/predint_sim.RData")

df <- tibble(coverage = as.vector(apply(simres.pi, c(2,3,4), mean)),
             est = factor(rep(rep(c("mean", "20% trimmed mean"), each = nn), 3)),
             n = rep(nseq, 6),
             pop = rep(c("normal", "lognormal", "contaminated normal"), each = nn*2)
            )

ggplot(df, aes(x = n, y = coverage, colour = pop, linetype = est)) + theme_gar +
  geom_point() +
  geom_line() +
  geom_hline(yintercept = 0.95) + 
  scale_x_continuous(breaks = nseq) +
  scale_y_continuous(limits = c(0.8, 1)) +
  scale_colour_manual(values = c("#000000", "#E69F00", "#56B4E9"))
  # theme(legend.position = "bottom")
```

## Plot results: confidence interval rule

```{r}
df <- tibble(coverage = as.vector(apply(simres.ci, c(2,3,4), mean)),
             est = factor(rep(rep(c("mean", "20% trimmed mean"), each = nn), 3)),
             n = rep(nseq, 6),
             pop = rep(c("normal", "lognormal", "contaminated normal"), each = nn*2)
            )

ggplot(df, aes(x = n, y = coverage, colour = pop, linetype = est)) + theme_gar +
  geom_point() +
  geom_line() +
  geom_hline(yintercept = 0.95) + 
  scale_x_continuous(breaks = nseq) +
  scale_y_continuous(limits = c(0.7, 1)) +
  scale_colour_manual(values = c("#000000", "#E69F00", "#56B4E9"))
  # theme(legend.position = "bottom")
```

# References
Spence, J. R., & Stanley, D. J. (2024). Tempered Expectations: A Tutorial for Calculating and Interpreting Prediction Intervals in the Context of Replications. Advances in Methods and Practices in Psychological Science, 7(1), 25152459231217932. https://doi.org/10.1177/25152459231217932

Wilcox, R. R., & Rousselet, G. A. (2023). An Updated Guide to Robust Statistical Methods in Neuroscience. Current Protocols, 3(3), e719. https://doi.org/10.1002/cpz1.719



